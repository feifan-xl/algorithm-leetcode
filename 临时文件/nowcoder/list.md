
- 反转链表


- 设计LRU缓存结构

- 判断链表中是否有环

- 用两个栈实现队列
  - 两个栈  insetStack removeStatck
  - 删除时取 removeStack 第一个  
  -  如果为空 则将insert中的 一个个导入remove

- 二分查找-II

- 跳台阶

- 在二叉树中找到两个节点的最近公共祖先
  - 递归 
  - (l && r) || (root.val === q.val || root.val === p.val) && (l || r)
  - 左右树的状态  l || r || (root.val === q.val || root.val === p.val) 

- 合并两个有序的数组
  - 双指针 尾部比对添加

- 寻找第K大
  - 快排  分治
    - 选取随机数 将比此数大的都放到一侧，调整索引
    - 返回此索引 与 k 进行比对， 确定左右边界 再次递归

- 最长回文子串
  - 中心扩散法  n^2
    - 遍历值 当做中心值  然后向左右扩散 直到不等 l >= 0 && r <s.length && s[r] === s[l]
    - 遍历时  做左右阈值 isPali(i,i)  isPali(i,i + 1)
  - dp
    - dp[i][j] = j-i > 3 ?  dp[i +1][j-1] && s[i] === s[j] : true

- 二叉树根节点到叶子节点和为指定值的路径
  - dfs比对

- 链表中的节点每k个一组翻转
  - 使用stack
  - 

- 全排列
  - 回溯

- 求平方根
  - 二分法

- 删除有序链表中重复的元素-II
  - 双指针比对 替换

- 两数之和
  - hash map

- 括号序列
  - map

- 斐波那契数列
  - 

- 岛屿数量
  - dfs 双循环 当前元素为1时，就为一个岛屿 遍历将其四个方向为1的都设置为0 一直递归
  - 边界 (r < 0 || l < 0 || r >= m || l >= n || grid[r][l] === '0'）
  - 面积 遍历+1
  - 周长 数学方式 求四个顶点

- 矩阵的最小路径和
  - dp dp[i][j] = Math.min(dp[i -1][j], dp[i][ j -1]) + grid[i,j]

- 合并区间
  - 排序， prev记录下前一个的值 然后首尾对比

- 最大数
  - 排序 快排 或 归并 比对条件  sx * y + x - sy * x + y
  - 3 * 100 + 30  30 * 10 + 3

- 数字在升序数组中出现的次数
  - 二分查找  查找左右两位

- 最大公约数
  - 辗转相除 a % b === 0  b / a-b

- 第一个只出现一次的字符重建二叉树

- 加起来和为目标值的组合
  - 

- 比较版本号