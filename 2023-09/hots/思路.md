

仔细分析 
    - 详细分析题意
    - 分析步骤时尽量先考虑好边界条件,凭经验区分哪些边界可以暂不考虑
    - 分析步骤时, 尽量从根源解决问题, 尤其是有样题的变种问题
    - 解法如果有简单中等复杂三种,可先选中等方式求解
    - 写函数 拆解步骤

具体怎么理清思路???
    - 笔写 还是脑子 过??
    

- 1.两数之和
- 3.无重复字符的最长子串
    - 滑动窗口: 一map保存不重复的数据, 有重复时l移动
- 5.最长回文子串
    - 中心扩散法: (i, i) (i, i + 1)
- 11.盛最多水的容器
    - 双指针
- 15. 三数之和
- 20.有效的括号
- 21. 合并两个有序链表
- 23.合并k个升序链表
    - 最小堆
    - 分治
- 25.k-个一组翻转链表
    - 先取k个 首尾翻转, 翻转函数中注意返回的是head tail, 且已与链表连接好
    - 一虚拟头节点,
- 31.下一个排列
    - 找规律:  
    - 第一个非递降索引， 然后更换从后面取第一个比他大的交换, 接着在旋转后面的改为递增
- 33. 搜索旋转排序数组
    - 双指针: 详细区分左右是升区间还是部分升区间
- 42.接雨水
    - 分步骤 取左右最大值 然后计算 
- 46. 全排列
    - dfs + used标识
- 53. 最大子数组和
    - dp[i] = Math.max(nums[i], dp[i - 1] + nums[i])
- 54.螺旋矩阵
    - 找出边界
    - 找出边界条件 
- 56.合并区间
- 88.合并两个有序数组
- 103. 二叉树的锯齿形层序遍历
- 121. 买卖股票的最佳时机
- 124.二叉树中的最大路径和
- 141.环形链表
- 142.环形链表-ii.js
    - 先快慢指针找出交点
    - 然后慢指针和头在next，相遇就是头结点
- 143.重排链表
    - 按步骤 取中间 翻转 合并
- 146.lru-缓存机制
    - map 存储 key-value 用来存取
    - 双向链表 用来维护使用生命周期
- 160.相交链表
- 200. 岛屿数量
    - dfs: 遍历后的做标记  
- 206.反转链表
    - 俩变量 tail 新链表的尾部, cur 原链表的首部
- 215.数组中的第k个最大元素
    - 最小堆: 构建一个最大堆, 因为可能会重复, 所以要删除k次堆顶元素
    - 快排：
    - 排序后双指针, 需注意去除重复项的时机
- 236.二叉树的最近公共祖先
    - dfs
- 1143.最长公共子序列
    - dp 需要注意dp[0][0]的问题

    